//采用PR状态方程，SCMP模型
//#include "StdAfx.h"
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include<math.h>
#include<iostream>
#include<cmath>
#include<cstdlib>
#include<iomanip>
#include<fstream>
#include<sstream>
#include<string>
#include <time.h>
#include <omp.h>
using namespace std;

#define R                                 30.0//initial(初始液滴半径)
#define LX                                101
#define LY                                101
#define LZ                                101
#define Q                                 19

#define X0                                 int((LX-1)/2.0) //液滴初始位置
#define Y0                                 int((LX-1)/2.0)
#define Z0                                 int((LZ-1)/2.0)//

#define Tcr                                0.0729 //PR方程对应的临界温度
#define T                                  (0.6*Tcr) //相应密度比对应的温度

 
#define tau0                               1.0 //弛豫时间
#define G                                  -1.0 //相间作用力参数


#define PI                               3.1415926


#define n0_in                              8.7248//液相密度 //8.7248
#define n0_out                             0.0102//气相密度
#define ERR                                1.0e-6//收敛判断
double R_const=1.0, a=2.0/49.0, b=2.0/21.0, w_pian=0.344, //水的偏心因子		   
alfa_T=(1.0+(0.37464+1.54226*w_pian-0.26992*w_pian*w_pian)*(1.0-sqrt(T/Tcr)))*(1.0+(0.37464+1.54226*w_pian-0.26992*w_pian*w_pian)*(1.0-sqrt(T/Tcr)));

double  e[Q][3],matrix[Q][Q],I_A[Q][Q],M_I_A[Q][Q],
        f0[LX][LY][LZ][Q],n0[LX][LY][LZ],psi0[LX][LY][LZ],
		veq0x[LX][LY][LZ],veq0y[LX][LY][LZ],veq0z[LX][LY][LZ],vx[LX][LY][LZ],vy[LX][LY][LZ],vz[LX][LY][LZ],
		vx0[LX][LY][LZ],vy0[LX][LY][LZ],vz0[LX][LY][LZ],
		g0[LX][LY][LZ][Q],F0x[LX][LY][LZ],F0y[LX][LY][LZ],F0z[LX][LY][LZ],error,mon[LX][LY][LZ][Q],meq[LX][LY][LZ][Q],S_eq[LX][LY][LZ][Q],
	    pressure[LX][LY][LZ],p[LX][LY][LZ];

double Sv = 1.1,//Sv=1.0/tau0,
S0=0.0,
//Se = 1.3,
Se=0.3,
SE=0.8,
Sq=1.2,
Spi=1.2,
St=1.8,
Y_factor=0.30;
//s={0.0,Se,SE,0.0,Sq,0.0,Sq,0.0,Sq,Sv,Spi,Sv,Spi,Sv,Sv,Sv,St,St,St}; 
//松弛矩阵S
double S_tau[Q][Q]={
{S0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, Se, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, SE, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, S0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, Sq, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, S0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, Sq, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, S0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, Sq, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,Sv, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, Spi, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, Sv, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, Spi, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, Sv, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, Sv, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, Sv, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, St, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, St, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, St}
};

double I_eye[Q][Q]={
{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}
};

double time0,time1;

double w[Q]={1.0/3,1.0/18,1.0/18,1.0/18,1.0/18,1.0/18,1.0/18,1.0/36,1.0/36,1.0/36,1.0/36,1.0/36,1.0/36,1.0/36,1.0/36,1.0/36,1.0/36,1.0/36,1.0/36}; 

double M[Q][Q]={
{1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,1.0, 1.0},
{-30.0, -11.0, -11.0, -11.0, -11.0, -11.0, -11.0, 8.0, 8.0, 8.0, 8.0, 8.0, 8.0, 8.0, 8.0, 8.0, 8.0,8.0, 8.0},
{12.0, -4.0, -4.0, -4.0, -4.0, -4.0, -4.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,1.0, 1.0},
{0.0, 1.0, -1.0, 0.0, 0.0, 0.0, 0.0, 1.0, -1.0,1.0, -1.0, 1.0, -1.0, 1.0, -1.0, 0.0, 0.0,0.0, 0.0},
{0.0, -4.0, 4.0, 0.0, 0.0, 0.0, 0.0, 1.0, -1.0,1.0, -1.0, 1.0, -1.0, 1.0, -1.0, 0.0, 0.0,0.0, 0.0},
{0.0, 0.0, 0.0, 1.0, -1.0, 0.0, 0.0, 1.0, 1.0,-1.0, -1.0, 0.0, 0.0, 0.0, 0.0, 1.0, -1.0,1.0, -1.0},
{0.0, 0.0, 0.0, -4.0, 4.0, 0.0, 0.0, 1.0, 1.0,-1.0, -1.0, 0.0, 0.0, 0.0, 0.0, 1.0, -1.0,1.0, -1.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 1.0, -1.0, 0.0, 0.0,0.0, 0.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0,-1.0, -1.0},
{0.0, 0.0, 0.0, 0.0, 0.0, -4.0, 4.0, 0.0, 0.0,0.0, 0.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0,-1.0, -1.0},
{0.0, 2.0, 2.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0,1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -2.0, -2.0,-2.0,-2.0},
{0.0, -4.0, -4.0, 2.0, 2.0, 2.0, 2.0, 1.0, 1.0,1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -2.0, -2.0,-2.0,-2.0},
{0.0, 0.0, 0.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0,1.0, 1.0, -1.0, -1.0, -1.0, -1.0, 0.0, 0.0,0.0,0.0},
{0.0, 0.0, 0.0, -2.0, -2.0, 2.0, 2.0, 1.0, 1.0,1.0, 1.0, -1.0, -1.0, -1.0, -1.0, 0.0, 0.0,0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, -1.0,-1.0, 1.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0,0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, -1.0,-1.0, 1.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 1.0, -1.0, -1.0, 1.0, 0.0, 0.0,0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, -1.0,1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 0.0, 0.0,0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, -1.0,1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, -1.0,1.0,-1.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0,1.0, 1.0}
};

/*
double M_inv[Q][Q]={ 
{1.0/19.0, -5.0/399.0, 1.0/21.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0},
{1.0/19.0, -11.0/2394.0, -1.0/63.0, 1.0/10.0, -1.0/10.0, 0.0, 0.0, 0.0, 0.0,1.0/18.0, -1.0/18.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0},
{1.0/19.0, -11.0/2394.0, -1.0/63.0, -1.0/10.0, 1.0/10.0, 0.0, 0.0, 0.0, 0.0,1.0/18.0, -1.0/18.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0},
{1.0/19.0, -11.0/2394.0, -1.0/63.0, 0.0, 0.0, 1.0/10.0, -1.0/10.0, 0.0, 0.0,-1.0/36.0, 1.0/36.0, 1.0/12.0, -1.0/12.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0},
{1.0/19.0, -11.0/2394.0, -1.0/63.0, 0.0, 0.0, -1.0/10.0,1.0/10.0, 0.0, 0.0,-1.0/36.0, 1.0/36.0, 1.0/12.0, -1.0/12.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0},
{1.0/19.0, -11.0/2394.0, -1.0/63.0, 0.0, 0.0, 0.0, 0.0,1.0/10.0, -1.0/10.0,-1.0/36.0, 1.0/36.0, -1.0/12.0, 1.0/12.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0},
{1.0/19.0, -11.0/2394.0, -1.0/63.0, 0.0, 0.0, 0.0, 0.0,-1.0/10.0, 1.0/10.0,-1.0/36.0, 1.0/36.0, -1.0/12.0,  1.0/12.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0},
{1.0/19.0, 4.0/1197.0, 1.0/252.0, 1.0/10.0, 1.0/40.0, 1.0/10.0,1.0/40.0,0.0, 0.0,1.0/36.0, 1.0/72.0, 1.0/12.0, 1.0/24.0, 1.0/4.0, 0.0, 0.0, 1.0/8.0,-1.0/8.0, 0.0},
{1.0/19.0, 4.0/1197.0, 1.0/252.0, -1.0/10.0, -1.0/40.0, 1.0/10.0,1.0/40.0,0.0, 0.0,1.0/36.0, 1.0/72.0, 1.0/12.0, 1.0/24.0, -1.0/4.0, 0.0, 0.0, -1.0/8.0,-1.0/8.0, 0.0},
{1.0/19.0, 4.0/1197.0, 1.0/252.0, 1.0/10.0, 1.0/40.0, -1.0/10.0,-1.0/40.0,0.0, 0.0,1.0/36.0, 1.0/72.0, 1.0/12.0, 1.0/24.0, -1.0/4.0, 0.0, 0.0, 1.0/8.0,1.0/8.0, 0.0},
{1.0/19.0, 4.0/1197.0, 1.0/252.0, -1.0/10.0, -1.0/40.0, -1.0/10.0,-1.0/40.0,0.0, 0.0,1.0/36.0, 1.0/72.0, 1.0/12.0,1.0/24.0, 1.0/4.0, 0.0, 0.0, -1.0/8.0,1.0/8.0, 0.0},
{1.0/19.0, 4.0/1197.0, 1.0/252.0, 1.0/10.0, 1.0/40.0, 0.0,0.0,1.0/10.0, 1.0/40.0,1.0/36.0, 1.0/72.0, -1.0/12.0, -1.0/24.0, 0.0, 0.0,1.0/4.0, -1.0/8.0,0.0, 1.0/8.0},
{1.0/19.0, 4.0/1197.0, 1.0/252.0, -1.0/10.0, -1.0/40.0, 0.0,0.0,1.0/10.0, 1.0/40.0,1.0/36.0, 1.0/72.0, -1.0/12.0,-1.0/24.0, 0.0, 0.0,-1.0/4.0, 1.0/8.0,0.0, 1.0/8.0},
{1.0/19.0, 4.0/1197.0, 1.0/252.0, 1.0/10.0, 1.0/40.0, 0.0,0.0,-1.0/10.0, -1.0/40.0,1.0/36.0, 1.0/72.0, -1.0/12.0, -1.0/24.0, 0.0, 0.0,-1.0/4.0, -1.0/8.0,0.0, -1.0/8.0},
{1.0/19.0, 4.0/1197.0, 1.0/252.0, -1.0/10.0, -1.0/40.0, 0.0,0.0,-1.0/10.0, -1.0/40.0,1.0/36.0, 1.0/72.0, -1.0/12.0, -1.0/24.0, 0.0, 0.0,1.0/4.0, 1.0/8.0,0.0, -1.0/8.0},
{1.0/19.0, 4.0/1197.0, 1.0/252.0, 0.0, 0.0, 1.0/10.0,1.0/40.0,1.0/10.0, 1.0/40.0,-1.0/18.0, -1.0/36.0, 0.0, 0.0, 0.0, 1.0/4.0,0.0, 0.0,1.0/8.0, -1.0/8.0},
{1.0/19.0, 4.0/1197.0, 1.0/252.0, 0.0, 0.0, -1.0/10.0, -1.0/40.0,1.0/10.0, 1.0/40.0,-1.0/18.0, -1.0/36.0, 0.0, 0.0, 0.0, -1.0/4.0,0.0, 0.0,-1.0/8.0, -1.0/8.0},
{1.0/19.0, 4.0/1197.0, 1.0/252.0, 0.0, 0.0, 1.0/10.0,1.0/40.0,-1.0/10.0, -1.0/40.0,-1.0/18.0, -1.0/36.0, 0.0, 0.0, 0.0, -1.0/4.0,0.0, 0.0,1.0/8.0, 1.0/8.0},
{1.0/19.0, 4.0/1197.0, 1.0/252.0, 0.0, 0.0, -1.0/10.0,-1.0/40.0,-1.0/10.0, -1.0/40.0,-1.0/18.0, -1.0/36.0, 0.0, 0.0,0.0, 1.0/4.0,0.0, 0.0,-1.0/8.0, 1.0/8.0}
};
*/

double M_inv[Q][Q] = { { 5.26315789e-02, -1.25313283e-02,4.76190476e-02 ,  5.08852220e-18,
1.27213055e-18,7.40148683e-18,7.40148683e-18,-2.55527522e-18,
- 0.00000000e+00,-3.70074342e-18,5.55111512e-18,-2.22044605e-17,
- 7.40148683e-18,-0.00000000e+00,1.26140628e-17,-2.92163954e-18,
3.70074342e-18,1.14546820e-18,2.92163954e-18 },
{ 5.26315789e-02,-4.59482038e-03,-1.58730159e-02,1.00000000e-01,
- 1.00000000e-01,-1.32169408e-17,-1.32169408e-17,2.97381167e-18,
- 0.00000000e+00,5.55555556e-02,-5.55555556e-02,2.64338815e-17,
- 0.00000000e+00,-6.93889390e-18,-1.62081432e-17,-1.02257384e-17,
- 1.73472348e-17,6.44325863e-18,1.02257384e-17 },
{ 5.26315789e-02,-4.59482038e-03,-1.58730159e-02,-1.00000000e-01,
1.00000000e-01,6.93889390e-18,6.93889390e-18,2.31296463e-18,
0.00000000e+00,5.55555556e-02,-5.55555556e-02,-6.93889390e-18,
0.00000000e+00,6.93889390e-18,1.46081977e-18,-1.46081977e-18,
1.73472348e-17,-8.09537622e-18,1.46081977e-18 },
{ 5.26315789e-02,-4.59482038e-03,-1.58730159e-02,-1.38777878e-17,
- 3.46944695e-18,1.00000000e-01,-1.00000000e-01,-1.85037171e-17,
0.00000000e+00,-2.77777778e-02,2.77777778e-02,8.33333333e-02,
- 8.33333333e-02,0.00000000e+00,1.36951853e-17,-1.02257384e-17,
0.00000000e+00,-1.15648232e-17,1.02257384e-17 },
{ 5.26315789e-02,-4.59482038e-03,-1.58730159e-02,1.82145965e-17,
4.55364912e-18,-1.00000000e-01,1.00000000e-01,-1.38777878e-17,
0.00000000e+00,-2.77777778e-02,2.77777778e-02,8.33333333e-02,
- 8.33333333e-02,3.46944695e-18,4.93026672e-18,-1.46081977e-18,
9.54097912e-18,1.21430643e-17,1.46081977e-18 },
{ 5.26315789e-02,-4.59482038e-03,-1.58730159e-02,-8.67361738e-18,
- 2.16840434e-18,5.20417043e-18,1.30104261e-18,1.00000000e-01,
- 1.00000000e-01,-2.77777778e-02,2.77777778e-02,-8.33333333e-02,
8.33333333e-02,-0.00000000e+00,-9.86053344e-18,2.92163954e-18,
- 1.73472348e-18,-0.00000000e+00,-2.92163954e-18 },
{ 5.26315789e-02,-4.59482038e-03,-1.58730159e-02,1.73472348e-18,
4.33680869e-19,1.73472348e-18,4.33680869e-19,-1.00000000e-01,
1.00000000e-01,-2.77777778e-02,2.77777778e-02,-8.33333333e-02,
8.33333333e-02,0.00000000e+00,-2.92163954e-18,2.92163954e-18,
- 1.73472348e-18,0.00000000e+00,-2.92163954e-18 },
{ 5.26315789e-02,3.34168755e-03,3.96825397e-03,1.00000000e-01,
2.50000000e-02,1.00000000e-01,2.50000000e-02,0.00000000e+00,
0.00000000e+00,2.77777778e-02,1.38888889e-02,8.33333333e-02,
4.16666667e-02,2.50000000e-01,3.50596745e-17,-3.50596745e-17,
1.25000000e-01,-1.25000000e-01,3.50596745e-17 },
{ 5.26315789e-02,3.34168755e-03,3.96825397e-03,-1.00000000e-01,
- 2.50000000e-02,1.00000000e-01,2.50000000e-02,-2.49800181e-18,
- 6.24500451e-19,2.77777778e-02,1.38888889e-02,8.33333333e-02,
4.16666667e-02,-2.50000000e-01,-1.17961196e-17,2.49800181e-17,
- 1.25000000e-01,-1.25000000e-01,-9.71445147e-18 },
{ 5.26315789e-02,3.34168755e-03,3.96825397e-03,1.00000000e-01,
2.50000000e-02,-1.00000000e-01,-2.50000000e-02,-1.11022302e-17,
- 2.77555756e-18,2.77777778e-02,1.38888889e-02,8.33333333e-02,
4.16666667e-02,-2.50000000e-01,-1.57281595e-17,-4.44089210e-17,
1.25000000e-01,1.25000000e-01,-1.11022302e-17 },
{ 5.26315789e-02,3.34168755e-03,3.96825397e-03,-1.00000000e-01,
- 2.50000000e-02,-1.00000000e-01,-2.50000000e-02,-6.38378239e-18,
- 1.59594560e-18,2.77777778e-02,1.38888889e-02,8.33333333e-02,
4.16666667e-02,2.50000000e-01,1.17961196e-17,4.16333634e-17,
- 1.25000000e-01,1.25000000e-01,9.71445147e-18 },
{ 5.26315789e-02,3.34168755e-03,3.96825397e-03,1.00000000e-01,
2.50000000e-02,1.85037171e-17,4.62592927e-18,1.00000000e-01,
2.50000000e-02,2.77777778e-02,1.38888889e-02,-8.33333333e-02,
- 4.16666667e-02,-5.55111512e-18,-1.85037171e-17,2.50000000e-01,
- 1.25000000e-01,-9.25185854e-18,1.25000000e-01 },
{ 5.26315789e-02,3.34168755e-03,3.96825397e-03,-1.00000000e-01,
- 2.50000000e-02,3.46944695e-18,8.67361738e-19,1.00000000e-01,
2.50000000e-02,2.77777778e-02,1.38888889e-02,-8.33333333e-02,
- 4.16666667e-02,5.55111512e-18,0.00000000e+00,-2.50000000e-01,
1.25000000e-01,-3.46944695e-18,1.25000000e-01 },
{ 5.26315789e-02,3.34168755e-03,3.96825397e-03,1.00000000e-01,
2.50000000e-02,-8.32667268e-18,-2.08166817e-18,-1.00000000e-01,
- 2.50000000e-02,2.77777778e-02,1.38888889e-02,-8.33333333e-02,
- 4.16666667e-02,-5.55111512e-18,1.11022302e-17,-2.50000000e-01,
- 1.25000000e-01,5.55111512e-18,-1.25000000e-01 },
{ 5.26315789e-02,3.34168755e-03,3.96825397e-03,-1.00000000e-01,
- 2.50000000e-02,3.46944695e-18,8.67361738e-19,-1.00000000e-01,
- 2.50000000e-02,2.77777778e-02,1.38888889e-02,-8.33333333e-02,
- 4.16666667e-02,5.55111512e-18,-6.93889390e-18,2.50000000e-01,
1.25000000e-01,-3.46944695e-18,-1.25000000e-01 },
{ 5.26315789e-02,3.34168755e-03,3.96825397e-03,-3.33066907e-18,
- 8.32667268e-19,1.00000000e-01,2.50000000e-02,1.00000000e-01,
2.50000000e-02,-5.55555556e-02,-2.77777778e-02,-4.62592927e-18,
- 2.31296463e-18,-3.08148791e-34,2.50000000e-01,3.85185989e-34,
- 6.93889390e-18,1.25000000e-01,-1.25000000e-01 },
{ 5.26315789e-02,3.34168755e-03,3.96825397e-03,3.33066907e-18,
8.32667268e-19,-1.00000000e-01,-2.50000000e-02,1.00000000e-01,
2.50000000e-02,-5.55555556e-02,-2.77777778e-02,4.62592927e-18,
2.31296463e-18,3.08148791e-34,-2.50000000e-01,-3.85185989e-34,
6.93889390e-18,-1.25000000e-01,-1.25000000e-01 },
{ 5.26315789e-02,3.34168755e-03,3.96825397e-03,-3.33066907e-18,
- 8.32667268e-19,1.00000000e-01,2.50000000e-02,-1.00000000e-01,
- 2.50000000e-02,-5.55555556e-02,-2.77777778e-02,-4.62592927e-18,
- 2.31296463e-18,-3.08148791e-34,-2.50000000e-01,3.85185989e-34,
- 6.93889390e-18,1.25000000e-01,1.25000000e-01 },
{ 5.26315789e-02,3.34168755e-03,3.96825397e-03,3.33066907e-18,
8.32667268e-19,-1.00000000e-01,-2.50000000e-02,-1.00000000e-01,
- 2.50000000e-02,-5.55555556e-02,-2.77777778e-02,4.62592927e-18,
2.31296463e-18,3.08148791e-34,2.50000000e-01,-3.85185989e-34,
6.93889390e-18,-1.25000000e-01,1.25000000e-01 }, };




double eq(int k,double n,double ux,double uy,double uz);
void initial(void);
void collision(void);
void stream(void);
void para(void);
void evolve(void);
double Error();
void output(int m);
void output_pressure(int m);




double eq(int k,double n,double ux,double uy,double uz)
{
	double eu,uv,feq;
	eu=(e[k][0]*ux+e[k][1]*uy+e[k][2]*uz);
	uv=(ux*ux+uy*uy+uz*uz);
	feq=w[k]*n*(1.0+3.0*eu+4.5*eu*eu-1.5*uv);
	return feq;
}

//initial
void initial()
{
	int k1, k2, k3;
	for(k1=0; k1<Q; k1++)
	{
		for(k2=0; k2<Q; k2++)
		{
			matrix[k1][k2] = 0.0;
			for(k3=0; k3<Q; k3++)
			{
				matrix[k1][k2] += M_inv[k1][k3] * S_tau[k3][k2];
			}
		}
	}

//计算I-S/2
	for(k1=0; k1<Q; k1++)
		for(k2=0; k2<Q; k2++)
		{
			I_A[k1][k2]=I_eye[k1][k2]-S_tau[k1][k2]/2.0;
		}
	
//计算M-1*(I-S/2)
	for(k1=0; k1<Q; k1++)
	{
		for(k2=0; k2<Q; k2++)
		{
			M_I_A[k1][k2] = 0.0;
			for(k3=0; k3<Q; k3++)
			{
				M_I_A[k1][k2] += M_inv[k1][k3] * I_A[k3][k2];
			}
		}
	}



	int i,j,k,z;
//#pragma omp parallel for private(i,j,z,k) num_threads(2)
 for(z=0;z<LZ;z++)
	for(j=0;j<LY;j++)
		for(i=0;i<LX;i++)//中心液滴		
		{
				/*		
				if((double((i-X0)*(i-X0)+(j-Y0)*(j-Y0)+(z-Z0)*(z-Z0)))<=R*R)
				{
					n0[i][j][z]=n0_in;
					
				}

				else
				{
					n0[i][j][z]=n0_out;
					
				}
				*/
				
				n0[i][j][z] =(n0_in+n0_out)/2.0-(n0_in-n0_out)/2.0*tanh(2.0*(sqrt(double((i-X0)*(i-X0) + (j-Y0)*(j-Y0)+ (z-Z0)*(z-Z0)))-R)/5.0);

				veq0x[i][j][z]=0.0;
				veq0y[i][j][z]=0.0;
				veq0z[i][j][z]=0.0;
			    vx[i][j][z]=0.0; //用于error判断
			    vy[i][j][z]=0.0;
				vz[i][j][z]=0.0;

				for(k=0;k<Q;k++)
				{
					f0[i][j][z][k]=eq(k,n0[i][j][z],veq0x[i][j][z],veq0y[i][j][z],veq0z[i][j][z]);

				}

		}
		para();

}
//collision
void collision()
{
	int i,j,k,z,k1,k2;
    double temp0,temp1,temp2,jx,jy,jz,temp3,temp_s;

//#pragma omp parallel for private(i,j,z,k,jx,jy,jz) num_threads(2)
for(z=0;z<LZ;z++)
	for(j=0;j<LY;j++)
		for(i=0;i<LX;i++)
		{

			    jx=n0[i][j][z]*vx[i][j][z];
                jy=n0[i][j][z]*vy[i][j][z];
                jz=n0[i][j][z]*vz[i][j][z];
                
                meq[i][j][z][0]=  n0[i][j][z];
                meq[i][j][z][1]=  -11.0*n0[i][j][z]+19.0/n0[i][j][z]*(jx*jx + jy*jy+jz*jz);
                meq[i][j][z][2]=  3.0*n0[i][j][z]-11.0/n0[i][j][z]/2.0*(jx*jx + jy*jy+jz*jz);
                meq[i][j][z][3]=  jx;
                meq[i][j][z][4]=  -2.0/3.0*jx;
                meq[i][j][z][5]=  jy;
                meq[i][j][z][6]=  -2.0/3.0*jy;
                meq[i][j][z][7]=  jz;
                meq[i][j][z][8]=  -2.0/3.0*jz;                
                meq[i][j][z][9]=  (2.0*jx*jx-jy*jy-jz*jz)/n0[i][j][z];
                meq[i][j][z][10]=  -0.5*(2.0*jx*jx-jy*jy-jz*jz)/n0[i][j][z];
                meq[i][j][z][11]=  (jy*jy-jz*jz)/n0[i][j][z];
                meq[i][j][z][12]=  -0.5*(jy*jy-jz*jz)/n0[i][j][z];
                meq[i][j][z][13]=  jx*jy/n0[i][j][z];
                meq[i][j][z][14]=  jy*jz/n0[i][j][z];
                meq[i][j][z][15]=  jx*jz/n0[i][j][z];
                meq[i][j][z][16]=  0.0;
                meq[i][j][z][17]=  0.0;
                meq[i][j][z][18]=  0.0;	

				S_eq[i][j][z][0]=  0.0;
                S_eq[i][j][z][1]=  38.0*(vx[i][j][z]*F0x[i][j][z]+vy[i][j][z]*F0y[i][j][z]+vz[i][j][z]*F0z[i][j][z])+ 114.0*Y_factor*(F0x[i][j][z]*F0x[i][j][z]+F0y[i][j][z]*F0y[i][j][z]+F0z[i][j][z]*F0z[i][j][z])/(1.0/Se-0.5)/psi0[i][j][z]/psi0[i][j][z];
                S_eq[i][j][z][2]=  -11.0*(vx[i][j][z]*F0x[i][j][z]+vy[i][j][z]*F0y[i][j][z]+vz[i][j][z]*F0z[i][j][z]);
                S_eq[i][j][z][3]=  F0x[i][j][z];
                S_eq[i][j][z][4]=  -2.0/3.0*F0x[i][j][z];
                S_eq[i][j][z][5]=  F0y[i][j][z];
                S_eq[i][j][z][6]= -2.0/3.0*F0y[i][j][z]; 
                S_eq[i][j][z][7]=  F0z[i][j][z];
                S_eq[i][j][z][8]= -2.0/3.0*F0z[i][j][z];               
                S_eq[i][j][z][9]= 4.0*vx[i][j][z]*F0x[i][j][z]-2.0*(vy[i][j][z]*F0y[i][j][z]+vz[i][j][z]*F0z[i][j][z]); 
                S_eq[i][j][z][10]= -2.0*vx[i][j][z]*F0x[i][j][z]+vy[i][j][z]*F0y[i][j][z]+vz[i][j][z]*F0z[i][j][z]; 
                S_eq[i][j][z][11]= 2.0*(vy[i][j][z]*F0y[i][j][z]-vz[i][j][z]*F0z[i][j][z]); 
                S_eq[i][j][z][12]= -1.0*(vy[i][j][z]*F0y[i][j][z]-vz[i][j][z]*F0z[i][j][z]);
                S_eq[i][j][z][13]= (vx[i][j][z]*F0y[i][j][z]+vy[i][j][z]*F0x[i][j][z]); 
                S_eq[i][j][z][14]= (vy[i][j][z]*F0z[i][j][z]+vz[i][j][z]*F0y[i][j][z]); 
                S_eq[i][j][z][15]= (vx[i][j][z]*F0z[i][j][z]+vz[i][j][z]*F0x[i][j][z]); 
                S_eq[i][j][z][16]=  0.0;
                S_eq[i][j][z][17]=  0.0;
                S_eq[i][j][z][18]=  0.0;

		}



//#pragma omp parallel for private(i,j,z,k1,k2,temp2) num_threads(2)
for(z=0;z<LZ;z++)
	for(j=0;j<LY;j++)
		for(i=0;i<LX;i++)
		{
		   	for(k1=0;k1<Q;k1++)		
				{	
					temp2 = 0.0;
					for (k2=0; k2<Q; k2++)
					{						
						temp2 = temp2 + M[k1][k2]*f0[i][j][z][k2];
					}
					mon[i][j][z][k1]=temp2;
				}

		}

//#pragma omp parallel for private(i,j,z,k1,k2,temp3,temp_s) num_threads(2)
  for(z=0;z<LZ;z++)
	for(j=0;j<LY;j++)
		for(i=0;i<LX;i++)
		{
			for(k1=0;k1<Q;k1++)		
				{	
					temp3 = 0.0;
					temp_s = 0.0;					
					for (k2=0; k2<Q; k2++)
					{						
						temp3 += matrix[k1][k2] * (mon[i][j][z][k2] - meq[i][j][z][k2]);
						temp_s += M_I_A[k1][k2] * S_eq[i][j][z][k2];
					}
					g0[i][j][z][k1]=f0[i][j][z][k1]-temp3+temp_s;
					
					if (g0[i][j][z][0] < 0){
						cout << "position " << i << " " << j << " " << z << endl;
						cout << "g0: " << g0[i][j][z][0] << endl;
						cout << "f0: " << f0[i][j][z][k1] << endl;
						cout << "temp3: " << temp3 << endl;
						cout << "temp_s" << temp_s << endl;
						for (int temp = 0; temp < Q; temp++){
							cout << "k: " << temp << " M_I_A: " << M_I_A[k1][temp] << endl; 
							cout << "k: " << temp << " Seq: " << S_eq[i][j][z][temp] << endl;
						}
						cout << "psi0[i][j][z]:" << psi0[i][j][z] << endl;
						cout << "v:" << vx[i][j][z] << " " <<
							vy[i][j][z] << " " <<
							vz[i][j][z] << endl;

						cout << "F:" << F0x[i][j][z] << " " <<
							F0y[i][j][z] << " " <<
							F0z[i][j][z] << endl;
						cout << "rho: " << n0[i][j][z] << endl;

						double Fx_temp = 0.0;
						double Fy_temp = 0.0;
						double Fz_temp = 0.0;

						for (int k2 = 1; k2<Q; k2++)
						{
							int id = i + int(e[k2][0]);
							int jd = j + int(e[k2][1]);
							int zd = z + int(e[k2][2]);
							if (id>LX - 1) id = 0; if (id<0) id = LX - 1;
							if (jd>LY - 1) jd = 0; if (jd<0) jd = LY - 1;
							if (zd>LZ - 1) zd = 0; if (zd<0) zd = LZ - 1;

							Fx_temp = Fx_temp + w[k2] * e[k2][0] * psi0[id][jd][zd];
							Fy_temp = Fy_temp + w[k2] * e[k2][1] * psi0[id][jd][zd];
							Fz_temp = Fz_temp + w[k2] * e[k2][2] * psi0[id][jd][zd];

							cout << "k2:" << k2 << " pos: " << id << " , " << jd << " , " << zd 
								<< " psi0: " << psi0[id][jd][zd] << " n0: " << n0[id][jd][zd] << endl;
							cout << "k2:" << k2 << " Fx_temp: " << w[k2] * e[k2][0] * psi0[id][jd][zd] << endl;
							cout << "k2:" << k2 << " Fy_temp: " << w[k2] * e[k2][1] * psi0[id][jd][zd] << endl;
							cout << "k2:" << k2 << " Fz_temp: " << w[k2] * e[k2][2] * psi0[id][jd][zd] << endl;
						}
						cout << "F0x[i][j][z] =" << -G*psi0[i][j][z] * Fx_temp << endl;
						cout << "F0y[i][j][z] =" << -G*psi0[i][j][z] * Fy_temp << endl;
						cout << "F0z[i][j][z] =" << -G*psi0[i][j][z] * Fz_temp << endl;


						cout << "error" << endl;
					}
					
				}

		}
	

}
//stream
void stream()
{
	int i,j,z,k,id,jd,zd;
//迁移步不用并行
 for(z=0;z<LZ;z++)
	for(i=0;i<LX;i++)  
		for(j=0;j<LY;j++)
		{
				for(k=0;k<Q;k++)
				{
					id=i-int(e[k][0]);
					jd=j-int(e[k][1]);
					zd=z-int(e[k][2]);
					if(id>LX-1) id=0;	if(id<0) id=LX-1;
					if(jd>LY-1) jd=0;	if(jd<0) jd=LY-1;
					if(zd>LZ-1) zd=0;   if(zd<0) zd=LZ-1;
	
				    f0[i][j][z][k]=g0[id][jd][zd][k];					
				}
		}
	
}
//para
void para()
{

		int i,j,k,z;
		double temp0;
		
//#pragma omp parallel for private(i,j,z,k,temp0) num_threads(2)
		for(z=0;z<LZ;z++)
			for(j=0;j<LY;j++)
				for(i=0;i<LX;i++)
				{
					temp0=0.0;
					for(k=0;k<Q;k++)
					 {
						temp0+=f0[i][j][z][k];

					 }

					if (temp0 < 0){
						int id, jd, zd;
						for (k = 0; k<Q; k++)
						{
							id = i - int(e[k][0]);
							jd = j - int(e[k][1]);
							zd = z - int(e[k][2]);
							if (id>LX - 1) id = 0;	if (id<0) id = LX - 1;
							if (jd>LY - 1) jd = 0;	if (jd<0) jd = LY - 1;
							if (zd>LZ - 1) zd = 0;   if (zd<0) zd = LZ - 1;
							cout << "k: " << k << " f: " << f0[i][j][z][k] << endl;
							cout << "k: " << k << " g: " << g0[id][jd][zd][k] << endl;

							double temp3 = 0.0;
							double temp_s = 0.0;
							for (int k2 = 0; k2<Q; k2++)
							{
								temp3 += matrix[k][k2] * (mon[i][j][z][k2] - meq[i][j][z][k2]);
								temp_s += M_I_A[k][k2] * S_eq[i][j][z][k2];
							}
							cout << "k: " << k << " temp3: " << temp3 << endl;
							cout << "k: " << k << " temp_s: " << temp_s << endl;

							double Fx_temp = 0.0;
							double Fy_temp = 0.0;
							double Fz_temp = 0.0;

							for (int k2 = 1; k2<Q; k2++)
							{
								id = i + int(e[k2][0]); jd = j + int(e[k2][1]); zd = z + int(e[k2][2]);
								if (id>LX - 1) id = 0; if (id<0) id = LX - 1;
								if (jd>LY - 1) jd = 0; if (jd<0) jd = LY - 1;
								if (zd>LZ - 1) zd = 0; if (zd<0) zd = LZ - 1;

								Fx_temp = Fx_temp + w[k2] * e[k2][0] * psi0[id][jd][zd];
								Fy_temp = Fy_temp + w[k2] * e[k2][1] * psi0[id][jd][zd];
								Fz_temp = Fz_temp + w[k2] * e[k2][2] * psi0[id][jd][zd];

								cout << "k2:" << k2 << " pos: " << id << " , " << jd << " , " << zd << " psi0: " << psi0[id][jd][zd] << endl;
								cout << "k2:" << k2 << " Fx_temp: " << w[k2] * e[k2][0] * psi0[id][jd][zd] << endl;
								cout << "k2:" << k2 << " Fy_temp: " << w[k2] * e[k2][1] * psi0[id][jd][zd] << endl;
								cout << "k2:" << k2 << " Fz_temp: " << w[k2] * e[k2][2] * psi0[id][jd][zd] << endl;
							}
							cout << "k: " << k << "F0x[i][j][z] =" << -G*psi0[i][j][z] * Fx_temp << endl;
							cout << "k: " << k << "F0y[i][j][z] =" << -G*psi0[i][j][z] * Fy_temp << endl;
							cout << "k: " << k << "F0z[i][j][z] =" << -G*psi0[i][j][z] * Fz_temp << endl;

						}
						cout << "v:" << veq0x[i][j][z] << " " <<
							veq0y[i][j][z] << " " <<
							veq0z[i][j][z] << endl;

						cout << "prev rho: " << n0[i][j][z] << endl;
						cout << "temp0: " << temp0 << endl;
						cout << "i: " << i << "j: " << j << "z: " << z << endl;
						cout << "error" << endl;
					}

					n0[i][j][z]=temp0; //格点密度

					

				pressure[i][j][z]=n0[i][j][z]*R_const*T/(1.0-b*n0[i][j][z])-a*alfa_T*n0[i][j][z]*n0[i][j][z]/(1.0+2.0*b*n0[i][j][z]-b*b*n0[i][j][z]*n0[i][j][z]);  //g取值G？？？
				psi0[i][j][z]=sqrt(abs(2.0*(pressure[i][j][z]-n0[i][j][z]/3.0)*3/G)); 

				if (isnan(psi0[i][j][z])){
					cout << "position " << i << " " << j << " " << z << endl;
					cout << "pis0: " << psi0[i][j][z] << endl;
					cout << "pressure: " << pressure[i][j][z] << endl;
					cout << "rho: " << n0[i][j][z] << endl;
					cout << "error" << endl;
				}

				}		
 

	int id,jd,zd;
	double Fx_temp,Fy_temp,Fz_temp;

//#pragma omp parallel for private(i,j,k,z,Fx_temp,Fy_temp,Fz_temp,id,jd,zd) num_threads(2)
	for(z=1;z<LZ-1;z++)
		for(j=0;j<LY;j++)
			for(i=0;i<LX;i++)
		{
		Fx_temp=0.0;
        Fy_temp=0.0;
        Fz_temp=0.0;
			
				for(k=1;k<Q;k++)
				{
					id=i+int(e[k][0]);jd=j+int(e[k][1]);zd=z+int(e[k][2]);
					if(id>LX-1) id=0; if(id<0) id=LX-1;
					if(jd>LY-1) jd=0; if(jd<0) jd=LY-1;
					if(zd>LZ-1) zd=0; if(zd<0) zd=LZ-1;	

					  Fx_temp= Fx_temp+w[k]*e[k][0]*psi0[id][jd][zd];
                      Fy_temp= Fy_temp+w[k]*e[k][1]*psi0[id][jd][zd]; 
					  Fz_temp= Fz_temp+w[k]*e[k][2]*psi0[id][jd][zd];                     
 
			   }
			F0x[i][j][z]=-G*psi0[i][j][z]*Fx_temp;
			F0y[i][j][z]=-G*psi0[i][j][z]*Fy_temp; 
			F0z[i][j][z]=-G*psi0[i][j][z]*Fz_temp;  

		}



double mome0x,mome0y,mome0z;

//#pragma omp parallel for private(i,j,k,z,mome0x,mome0y,mome0z) num_threads(2)
	for(z=0;z<LZ;z++)
		for(j=0;j<LY;j++)
			for(i=0;i<LX;i++)
		{			
				vx0[i][j][z]=vx[i][j][z]; //保存上一时刻真实速度，用于收敛判断
				vy0[i][j][z]=vy[i][j][z];
				vz0[i][j][z]=vz[i][j][z];
				mome0x=mome0y=mome0z=0.0;
				for(k=0;k<Q;k++)
				{
					mome0x+=f0[i][j][z][k]*e[k][0]; //x方向动量
					mome0y+=f0[i][j][z][k]*e[k][1]; //y方向动量
					mome0z+=f0[i][j][z][k]*e[k][2]; //z方向动量
					
				}
				mome0x=mome0x;mome0y=mome0y;mome0z=mome0z;				


				veq0x[i][j][z]=(mome0x/n0[i][j][z]); // 平衡态速度
				veq0y[i][j][z]=(mome0y/n0[i][j][z]);
				veq0z[i][j][z]=(mome0z/n0[i][j][z]);

				vx[i][j][z]=(veq0x[i][j][z]+0.5*F0x[i][j][z]/n0[i][j][z]); //真实速度
				vy[i][j][z]=(veq0y[i][j][z]+0.5*F0y[i][j][z]/n0[i][j][z]);
				vz[i][j][z]=(veq0z[i][j][z]+0.5*F0z[i][j][z]/n0[i][j][z]);

		}

			

}

//evolve
void evolve()
{
	
	collision();
	stream();
	para();
	
}


double Error()
{
	int i,j,z;
	double temp1,temp2,err;
	temp1=0;
	temp2=0;

//#pragma omp parallel for reduction(+:temp1,temp2)
	for(z=1;z<LZ-1;z++)
		for(i=0;i<LX;i++)
			for(j=0;j<LY;j++)
			{
				temp1+=(vx[i][j][z]-vx0[i][j][z])*(vx[i][j][z]-vx0[i][j][z])+(vy[i][j][z]-vy0[i][j][z])*(vy[i][j][z]-vy0[i][j][z])+(vz[i][j][z]-vz0[i][j][z])*(vz[i][j][z]-vz0[i][j][z]);
				temp2+=(vx[i][j][z]*vx[i][j][z]+vy[i][j][z]*vy[i][j][z]+vz[i][j][z]*vz[i][j][z]);
			}
			temp1=sqrt(temp1);
			temp2=sqrt(temp2);
			err=temp1/(temp2);
			return err;
}


void output(int m)  //输出
{
	/*
	int i,j,z; 

	ostringstream name;	
	name<<"result_"<<m<<".dat";
	ofstream out(name.str().c_str());
	out<<"Title=\"Laplace Equation\"\n"<<"VARIABLES=\"X\",\"Y\",\"Z\",\"V1\",\"V2\",\"V3\",\"Rho\",\"Pressure\"\n"<<"ZONE T=\"BOX\",I="
		<<LX<<",J="<<LY<<",K="<<LZ<<",F=POINT"<<endl;

	for(z=0;z<LZ;z++)
		for(j=0;j<LY;j++)
			for(i=0;i<LX;i++)
			{
				out<<i<<"   "<<j<<"   "<<z<<"   "<<vx[i][j][z]<<"   "<<vy[i][j][z]<<"   "<<vz[i][j][z]<<"   "<<n0[i][j][z]<<"   "<<pressure[i][j][z]<<endl;
			}
	*/
	int i, j, z;
	ostringstream name;
	name << "cavity_" << m << ".data";
	ofstream out(name.str().c_str(), ofstream::binary);
	/*
	for (j = 0; j<LY; j++)
		for (i = 0; i<LX; i++){
			out.write((char*)&n0[i][j][Z0], sizeof(double));
		}
		*/
	for (j = 0; j < LY; j++)
		for (z = 0; z < LZ; z++){
			out.write((char*)&n0[X0][j][z], sizeof(double));
		}
}


void output_pressure(int m)
{

	ostringstream name;
	int z;
	name<<"pressure_"<<m<<".txt";
	ofstream out(name.str().c_str());	
		for(z=0;z<LZ;z++)
		{
			out<<z<<"   "<<n0[X0][Y0][z]<<"   "<<pressure[X0][Y0][z]<<endl;
		}
		


}

//main
void main()
{
	using namespace std;
	
	e[0][0]=0.0;  e[0][1]=0.0;  e[0][2]=0.0;
	e[1][0]=1.0;  e[1][1]=0.0;  e[1][2]=0.0;
	e[2][0]=-1.0;  e[2][1]=0.0;  e[2][2]=0.0;
	e[3][0]=0.0; e[3][1]=1.0;  e[3][2]=0.0;
	e[4][0]=0.0;  e[4][1]=-1.0;  e[4][2]=0.0;

	e[5][0]=0.0;  e[5][1]=0.0;  e[5][2]=1.0;
	e[6][0]=0.0; e[6][1]=0.0;  e[6][2]=-1.0;
	e[7][0]=1.0; e[7][1]=1.0;  e[7][2]=0.0;
	e[8][0]=-1.0;  e[8][1]=1.0;  e[8][2]=0.0;
	e[9][0]=1.0;  e[9][1]=-1.0;  e[9][2]=0.0;

	e[10][0]=-1.0;  e[10][1]=-1.0;  e[10][2]=0.0;
	e[11][0]=1.0;  e[11][1]=0.0;  e[11][2]=1.0;
	e[12][0]=-1.0;  e[12][1]=0.0;  e[12][2]=1.0;
	e[13][0]=1.0;  e[13][1]=0.0;  e[13][2]=-1.0;
	e[14][0]=-1.0;  e[14][1]=0.0;  e[14][2]=-1.0;

	e[15][0]=0.0;  e[15][1]=1.0;  e[15][2]=1.0;
	e[16][0]=0.0;  e[16][1]=-1.0;  e[16][2]=1.0;
	e[17][0]=0.0;  e[17][1]=1.0;  e[17][2]=-1.0;
	e[18][0]=0.0;  e[18][1]=-1.0;  e[18][2]=-1.0;
	

	time0=clock();	
	initial();	
	printf("Start calculation, wait...\n");
	int m; //循环赋值

	for(m=0;m<=10000 ;m++)
	{
		evolve();
		time1=clock();
		//if(m%5==0)
		{
			//error=Error();
			cout<<"The"<<m<<"th computation result:"<<endl<<"The densities 4,3,2,1 are:"
				<<setprecision(6)<<n0[X0][Y0][Z0]<<","<<n0[0][0][0]<<endl;
			//cout<<"The max relative error of uv is:"<<setiosflags(ios::scientific)<<error<<endl;
			printf("时间=%f秒\n",(time1-time0)/1000.0);
			
		}

		//if(m%50==0)
		{
			
			output(m); //输出数据
			output_pressure(m);

		}
		
		
	}

	

    //printf("最终误差error=%e\t最终循环次数IT=%d\n",error,m);

  system("pause");

}
