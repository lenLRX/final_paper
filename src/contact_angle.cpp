//采用PR状态方程，SCMP模型
//#include "StdAfx.h"
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include<math.h>
#include<iostream>
#include<cmath>
#include<cstdlib>
#include<iomanip>
#include<fstream>
#include<sstream>
#include<string>
#include <time.h>
#include <omp.h>
using namespace std;

#define R                                 30.0//initial(初始液滴半径)
#define LX                                101
#define LY                                101
#define LZ                                101
#define Q                                 19

#define X0                                 int((LX-1)/2.0) //液滴初始位置
#define Y0                                 int((LX-1)/2.0)
#define Z0                                 int((LZ-1)/2.0)//

#define Tcr                                0.0729 //PR方程对应的临界温度
#define T                                  (0.85*Tcr) //相应密度比对应的温度

 
#define tau0                               1.0 //弛豫时间
#define G                                  -1.0 //相间作用力参数


#define PI                               3.1415926


#define n0_in                              6.6293//液相密度
#define n0_out                             0.3413//气相密度
#define ERR                                1.0e-6//收敛判断
double R_const=1.0, a=2.0/49.0, b=2.0/21.0, w_pian=0.344, //水的偏心因子		   
alfa_T=(1.0+(0.37464+1.54226*w_pian-0.26992*w_pian*w_pian)*(1.0-sqrt(T/Tcr)))*(1.0+(0.37464+1.54226*w_pian-0.26992*w_pian*w_pian)*(1.0-sqrt(T/Tcr)));

double  e[Q][3],matrix[Q][Q],I_A[Q][Q],M_I_A[Q][Q],
        f0[LX][LY][LZ][Q],n0[LX][LY][LZ],psi0[LX][LY][LZ],
		veq0x[LX][LY][LZ],veq0y[LX][LY][LZ],veq0z[LX][LY][LZ],vx[LX][LY][LZ],vy[LX][LY][LZ],vz[LX][LY][LZ],
		vx0[LX][LY][LZ],vy0[LX][LY][LZ],vz0[LX][LY][LZ],
		g0[LX][LY][LZ][Q],F0x[LX][LY][LZ],F0y[LX][LY][LZ],F0z[LX][LY][LZ],error,mon[LX][LY][LZ][Q],meq[LX][LY][LZ][Q],S_eq[LX][LY][LZ][Q],
	    pressure[LX][LY][LZ],p[LX][LY][LZ];

double Sv=1.0/tau0,
S0=0.0,
Se=0.3,
SE=0.8,
Sq=1.2,
Spi=1.2,
St=1.8,
Y_factor=0.30;
//s={0.0,Se,SE,0.0,Sq,0.0,Sq,0.0,Sq,Sv,Spi,Sv,Spi,Sv,Sv,Sv,St,St,St}; 
//松弛矩阵S
double S_tau[Q][Q]={
{S0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, Se, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, SE, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, S0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, Sq, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, S0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, Sq, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, S0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, Sq, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,Sv, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, Spi, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, Sv, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, Spi, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, Sv, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, Sv, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, Sv, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, St, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, St, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, St}
};

double I_eye[Q][Q]={
{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}
};

double time0,time1;

double w[Q]={1.0/3,1.0/18,1.0/18,1.0/18,1.0/18,1.0/18,1.0/18,1.0/36,1.0/36,1.0/36,1.0/36,1.0/36,1.0/36,1.0/36,1.0/36,1.0/36,1.0/36,1.0/36,1.0/36}; 

double M[Q][Q]={
{1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,1.0, 1.0},
{-30.0, -11.0, -11.0, -11.0, -11.0, -11.0, -11.0, 8.0, 8.0, 8.0, 8.0, 8.0, 8.0, 8.0, 8.0, 8.0, 8.0,8.0, 8.0},
{12.0, -4.0, -4.0, -4.0, -4.0, -4.0, -4.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,1.0, 1.0},
{0.0, 1.0, -1.0, 0.0, 0.0, 0.0, 0.0, 1.0, -1.0,1.0, -1.0, 1.0, -1.0, 1.0, -1.0, 0.0, 0.0,0.0, 0.0},
{0.0, -4.0, 4.0, 0.0, 0.0, 0.0, 0.0, 1.0, -1.0,1.0, -1.0, 1.0, -1.0, 1.0, -1.0, 0.0, 0.0,0.0, 0.0},
{0.0, 0.0, 0.0, 1.0, -1.0, 0.0, 0.0, 1.0, 1.0,-1.0, -1.0, 0.0, 0.0, 0.0, 0.0, 1.0, -1.0,1.0, -1.0},
{0.0, 0.0, 0.0, -4.0, 4.0, 0.0, 0.0, 1.0, 1.0,-1.0, -1.0, 0.0, 0.0, 0.0, 0.0, 1.0, -1.0,1.0, -1.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 1.0, -1.0, 0.0, 0.0,0.0, 0.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0,-1.0, -1.0},
{0.0, 0.0, 0.0, 0.0, 0.0, -4.0, 4.0, 0.0, 0.0,0.0, 0.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0,-1.0, -1.0},
{0.0, 2.0, 2.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0,1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -2.0, -2.0,-2.0,-2.0},
{0.0, -4.0, -4.0, 2.0, 2.0, 2.0, 2.0, 1.0, 1.0,1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -2.0, -2.0,-2.0,-2.0},
{0.0, 0.0, 0.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0,1.0, 1.0, -1.0, -1.0, -1.0, -1.0, 0.0, 0.0,0.0,0.0},
{0.0, 0.0, 0.0, -2.0, -2.0, 2.0, 2.0, 1.0, 1.0,1.0, 1.0, -1.0, -1.0, -1.0, -1.0, 0.0, 0.0,0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, -1.0,-1.0, 1.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0,0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, -1.0,-1.0, 1.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 1.0, -1.0, -1.0, 1.0, 0.0, 0.0,0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, -1.0,1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 0.0, 0.0,0.0, 0.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, -1.0,1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, -1.0,1.0,-1.0},
{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0,1.0, 1.0}
};

double M_inv[Q][Q]={ 
{1.0/19.0, -5.0/399.0, 1.0/21.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0},
{1.0/19.0, -11.0/2394.0, -1.0/63.0, 1.0/10.0, -1.0/10.0, 0.0, 0.0, 0.0, 0.0,1.0/18.0, -1.0/18.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0},
{1.0/19.0, -11.0/2394.0, -1.0/63.0, -1.0/10.0, 1.0/10.0, 0.0, 0.0, 0.0, 0.0,1.0/18.0, -1.0/18.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0},
{1.0/19.0, -11.0/2394.0, -1.0/63.0, 0.0, 0.0, 1.0/10.0, -1.0/10.0, 0.0, 0.0,-1.0/36.0, 1.0/36.0, 1.0/12.0, -1.0/12.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0},
{1.0/19.0, -11.0/2394.0, -1.0/63.0, 0.0, 0.0, -1.0/10.0,1.0/10.0, 0.0, 0.0,-1.0/36.0, 1.0/36.0, 1.0/12.0, -1.0/12.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0},
{1.0/19.0, -11.0/2394.0, -1.0/63.0, 0.0, 0.0, 0.0, 0.0,1.0/10.0, -1.0/10.0,-1.0/36.0, 1.0/36.0, -1.0/12.0, 1.0/12.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0},
{1.0/19.0, -11.0/2394.0, -1.0/63.0, 0.0, 0.0, 0.0, 0.0,-1.0/10.0, 1.0/10.0,-1.0/36.0, 1.0/36.0, -1.0/12.0,  1.0/12.0, 0.0, 0.0, 0.0, 0.0,0.0, 0.0},
{1.0/19.0, 4.0/1197.0, 1.0/252.0, 1.0/10.0, 1.0/40.0, 1.0/10.0,1.0/40.0,0.0, 0.0,1.0/36.0, 1.0/72.0, 1.0/12.0, 1.0/24.0, 1.0/4.0, 0.0, 0.0, 1.0/8.0,-1.0/8.0, 0.0},
{1.0/19.0, 4.0/1197.0, 1.0/252.0, -1.0/10.0, -1.0/40.0, 1.0/10.0,1.0/40.0,0.0, 0.0,1.0/36.0, 1.0/72.0, 1.0/12.0, 1.0/24.0, -1.0/4.0, 0.0, 0.0, -1.0/8.0,-1.0/8.0, 0.0},
{1.0/19.0, 4.0/1197.0, 1.0/252.0, 1.0/10.0, 1.0/40.0, -1.0/10.0,-1.0/40.0,0.0, 0.0,1.0/36.0, 1.0/72.0, 1.0/12.0, 1.0/24.0, -1.0/4.0, 0.0, 0.0, 1.0/8.0,1.0/8.0, 0.0},
{1.0/19.0, 4.0/1197.0, 1.0/252.0, -1.0/10.0, -1.0/40.0, -1.0/10.0,-1.0/40.0,0.0, 0.0,1.0/36.0, 1.0/72.0, 1.0/12.0,1.0/24.0, 1.0/4.0, 0.0, 0.0, -1.0/8.0,1.0/8.0, 0.0},
{1.0/19.0, 4.0/1197.0, 1.0/252.0, 1.0/10.0, 1.0/40.0, 0.0,0.0,1.0/10.0, 1.0/40.0,1.0/36.0, 1.0/72.0, -1.0/12.0, -1.0/24.0, 0.0, 0.0,1.0/4.0, -1.0/8.0,0.0, 1.0/8.0},
{1.0/19.0, 4.0/1197.0, 1.0/252.0, -1.0/10.0, -1.0/40.0, 0.0,0.0,1.0/10.0, 1.0/40.0,1.0/36.0, 1.0/72.0, -1.0/12.0,-1.0/24.0, 0.0, 0.0,-1.0/4.0, 1.0/8.0,0.0, 1.0/8.0},
{1.0/19.0, 4.0/1197.0, 1.0/252.0, 1.0/10.0, 1.0/40.0, 0.0,0.0,-1.0/10.0, -1.0/40.0,1.0/36.0, 1.0/72.0, -1.0/12.0, -1.0/24.0, 0.0, 0.0,-1.0/4.0, -1.0/8.0,0.0, -1.0/8.0},
{1.0/19.0, 4.0/1197.0, 1.0/252.0, -1.0/10.0, -1.0/40.0, 0.0,0.0,-1.0/10.0, -1.0/40.0,1.0/36.0, 1.0/72.0, -1.0/12.0, -1.0/24.0, 0.0, 0.0,1.0/4.0, 1.0/8.0,0.0, -1.0/8.0},
{1.0/19.0, 4.0/1197.0, 1.0/252.0, 0.0, 0.0, 1.0/10.0,1.0/40.0,1.0/10.0, 1.0/40.0,-1.0/18.0, -1.0/36.0, 0.0, 0.0, 0.0, 1.0/4.0,0.0, 0.0,1.0/8.0, -1.0/8.0},
{1.0/19.0, 4.0/1197.0, 1.0/252.0, 0.0, 0.0, -1.0/10.0, -1.0/40.0,1.0/10.0, 1.0/40.0,-1.0/18.0, -1.0/36.0, 0.0, 0.0, 0.0, -1.0/4.0,0.0, 0.0,-1.0/8.0, -1.0/8.0},
{1.0/19.0, 4.0/1197.0, 1.0/252.0, 0.0, 0.0, 1.0/10.0,1.0/40.0,-1.0/10.0, -1.0/40.0,-1.0/18.0, -1.0/36.0, 0.0, 0.0, 0.0, -1.0/4.0,0.0, 0.0,1.0/8.0, 1.0/8.0},
{1.0/19.0, 4.0/1197.0, 1.0/252.0, 0.0, 0.0, -1.0/10.0,-1.0/40.0,-1.0/10.0, -1.0/40.0,-1.0/18.0, -1.0/36.0, 0.0, 0.0,0.0, 1.0/4.0,0.0, 0.0,-1.0/8.0, 1.0/8.0}
};



double eq(int k,double n,double ux,double uy,double uz);
void initial(void);
void collision(void);
void stream(void);
void para(void);
void evolve(void);
double Error();
void output(int m);
void output_pressure(int m);




double eq(int k,double n,double ux,double uy,double uz)
{
	double eu,uv,feq;
	eu=(e[k][0]*ux+e[k][1]*uy+e[k][2]*uz);
	uv=(ux*ux+uy*uy+uz*uz);
	feq=w[k]*n*(1.0+3.0*eu+4.5*eu*eu-1.5*uv);
	return feq;
}

//initial
void initial()
{
	int k1, k2, k3;
	for(k1=0; k1<Q; k1++)
	{
		for(k2=0; k2<Q; k2++)
		{
			matrix[k1][k2] = 0.0;
			for(k3=0; k3<Q; k3++)
			{
				matrix[k1][k2] += M_inv[k1][k3] * S_tau[k3][k2];
			}
		}
	}

//计算I-S/2
	for(k1=0; k1<Q; k1++)
		for(k2=0; k2<Q; k2++)
		{
			I_A[k1][k2]=I_eye[k1][k2]-S_tau[k1][k2]/2.0;
		}
	
//计算M-1*(I-S/2)
	for(k1=0; k1<Q; k1++)
	{
		for(k2=0; k2<Q; k2++)
		{
			M_I_A[k1][k2] = 0.0;
			for(k3=0; k3<Q; k3++)
			{
				M_I_A[k1][k2] += M_inv[k1][k3] * I_A[k3][k2];
			}
		}
	}



	int i,j,k,z;
#pragma omp parallel for private(i,j,z,k) num_threads(2)
 for(z=0;z<LZ;z++)
	for(j=0;j<LY;j++)
		for(i=0;i<LX;i++)//中心液滴		
		{
				/*		
				if((double((i-X0)*(i-X0)+(j-Y0)*(j-Y0)+(z-Z0)*(z-Z0)))<=R*R)
				{
					n0[i][j][z]=n0_in;
					
				}

				else
				{
					n0[i][j][z]=n0_out;
					
				}
				*/
				
				n0[i][j][z] =(n0_in+n0_out)/2.0-(n0_in-n0_out)/2.0*tanh(2.0*(sqrt(double((i-X0)*(i-X0) + (j-Y0)*(j-Y0)+ (z-Z0)*(z-Z0)))-R)/5.0);

				veq0x[i][j][z]=0.0;
				veq0y[i][j][z]=0.0;
				veq0z[i][j][z]=0.0;
			    vx[i][j][z]=0.0; //用于error判断
			    vy[i][j][z]=0.0;
				vz[i][j][z]=0.0;

				for(k=0;k<Q;k++)
				{
					f0[i][j][z][k]=eq(k,n0[i][j][z],veq0x[i][j][z],veq0y[i][j][z],veq0z[i][j][z]);

				}

		}
		para();

}
//collision
void collision()
{
	int i,j,k,z,k1,k2;
    double temp0,temp1,temp2,jx,jy,jz,temp3,temp_s;

#pragma omp parallel for private(i,j,z,k,jx,jy,jz) num_threads(2)
for(z=0;z<LZ;z++)
	for(j=0;j<LY;j++)
		for(i=0;i<LX;i++)
		{

			    jx=n0[i][j][z]*vx[i][j][z];
                jy=n0[i][j][z]*vy[i][j][z];
                jz=n0[i][j][z]*vz[i][j][z];
                
                meq[i][j][z][0]=  n0[i][j][z];
                meq[i][j][z][1]=  -11.0*n0[i][j][z]+19.0/n0[i][j][z]*(jx*jx + jy*jy+jz*jz);
                meq[i][j][z][2]=  3.0*n0[i][j][z]-11.0/n0[i][j][z]/2.0*(jx*jx + jy*jy+jz*jz);
                meq[i][j][z][3]=  jx;
                meq[i][j][z][4]=  -2.0/3.0*jx;
                meq[i][j][z][5]=  jy;
                meq[i][j][z][6]=  -2.0/3.0*jy;
                meq[i][j][z][7]=  jz;
                meq[i][j][z][8]=  -2.0/3.0*jz;                
                meq[i][j][z][9]=  (2.0*jx*jx-jy*jy-jz*jz)/n0[i][j][z];
                meq[i][j][z][10]=  -0.5*(2.0*jx*jx-jy*jy-jz*jz)/n0[i][j][z];
                meq[i][j][z][11]=  (jy*jy-jz*jz)/n0[i][j][z];
                meq[i][j][z][12]=  -0.5*(jy*jy-jz*jz)/n0[i][j][z];
                meq[i][j][z][13]=  jx*jy/n0[i][j][z];
                meq[i][j][z][14]=  jy*jz/n0[i][j][z];
                meq[i][j][z][15]=  jx*jz/n0[i][j][z];
                meq[i][j][z][16]=  0.0;
                meq[i][j][z][17]=  0.0;
                meq[i][j][z][18]=  0.0;	

				S_eq[i][j][z][0]=  0.0;
                S_eq[i][j][z][1]=  38.0*(vx[i][j][z]*F0x[i][j][z]+vy[i][j][z]*F0y[i][j][z]+vz[i][j][z]*F0z[i][j][z])+ 114.0*Y_factor*(F0x[i][j][z]*F0x[i][j][z]+F0y[i][j][z]*F0y[i][j][z]+F0z[i][j][z]*F0z[i][j][z])/(1.0/Se-0.5)/psi0[i][j][z]/psi0[i][j][z];
                S_eq[i][j][z][2]=  -11.0*(vx[i][j][z]*F0x[i][j][z]+vy[i][j][z]*F0y[i][j][z]+vz[i][j][z]*F0z[i][j][z]);
                S_eq[i][j][z][3]=  F0x[i][j][z];
                S_eq[i][j][z][4]=  -2.0/3.0*F0x[i][j][z];
                S_eq[i][j][z][5]=  F0y[i][j][z];
                S_eq[i][j][z][6]= -2.0/3.0*F0y[i][j][z]; 
                S_eq[i][j][z][7]=  F0z[i][j][z];
                S_eq[i][j][z][8]= -2.0/3.0*F0z[i][j][z];               
                S_eq[i][j][z][9]= 4.0*vx[i][j][z]*F0x[i][j][z]-2.0*(vy[i][j][z]*F0y[i][j][z]+vz[i][j][z]*F0z[i][j][z]); 
                S_eq[i][j][z][10]= -2.0*vx[i][j][z]*F0x[i][j][z]+vy[i][j][z]*F0y[i][j][z]+vz[i][j][z]*F0z[i][j][z]; 
                S_eq[i][j][z][11]= 2.0*(vy[i][j][z]*F0y[i][j][z]-vz[i][j][z]*F0z[i][j][z]); 
                S_eq[i][j][z][12]= -1.0*(vy[i][j][z]*F0y[i][j][z]-vz[i][j][z]*F0z[i][j][z]);
                S_eq[i][j][z][13]= (vx[i][j][z]*F0y[i][j][z]+vy[i][j][z]*F0x[i][j][z]); 
                S_eq[i][j][z][14]= (vy[i][j][z]*F0z[i][j][z]+vz[i][j][z]*F0y[i][j][z]); 
                S_eq[i][j][z][15]= (vx[i][j][z]*F0z[i][j][z]+vz[i][j][z]*F0x[i][j][z]); 
                S_eq[i][j][z][16]=  0.0;
                S_eq[i][j][z][17]=  0.0;
                S_eq[i][j][z][18]=  0.0;

		}



#pragma omp parallel for private(i,j,z,k1,k2,temp2) num_threads(2)
for(z=0;z<LZ;z++)
	for(j=0;j<LY;j++)
		for(i=0;i<LX;i++)
		{
		   	for(k1=0;k1<Q;k1++)		
				{	
					temp2 = 0.0;
					for (k2=0; k2<Q; k2++)
					{						
						temp2 = temp2 + M[k1][k2]*f0[i][j][z][k2];
					}
					mon[i][j][z][k1]=temp2;
				}

		}

#pragma omp parallel for private(i,j,z,k1,k2,temp3,temp_s) num_threads(2)
  for(z=0;z<LZ;z++)
	for(j=0;j<LY;j++)
		for(i=0;i<LX;i++)
		{
			for(k1=0;k1<Q;k1++)		
				{	
					temp3 = 0.0;
					temp_s = 0.0;					
					for (k2=0; k2<Q; k2++)
					{						
						temp3 += matrix[k1][k2] * (mon[i][j][z][k2] - meq[i][j][z][k2]);
						temp_s += M_I_A[k1][k2] * S_eq[i][j][z][k2];
					}
					g0[i][j][z][k1]=f0[i][j][z][k1]-temp3+temp_s;
					
				}

		}
	

}
//stream
void stream()
{
	int i,j,z,k,id,jd,zd;
//迁移步不用并行
 for(z=0;z<LZ;z++)
	for(i=0;i<LX;i++)  
		for(j=0;j<LY;j++)
		{
				for(k=0;k<Q;k++)
				{
					id=i-int(e[k][0]);
					jd=j-int(e[k][1]);
					zd=z-int(e[k][2]);
					if(id>LX-1) id=0;	if(id<0) id=LX-1;
					if(jd>LY-1) jd=0;	if(jd<0) jd=LY-1;
					if(zd>LZ-1) zd=0;   if(zd<0) zd=LZ-1;
	
				    f0[i][j][z][k]=g0[id][jd][zd][k];					
				}
		}
	
}
//para
void para()
{

		int i,j,k,z;
		double temp0;
		
#pragma omp parallel for private(i,j,z,k,temp0) num_threads(2)
		for(z=0;z<LZ;z++)
			for(j=0;j<LY;j++)
				for(i=0;i<LX;i++)
				{
					temp0=0.0;
					for(k=0;k<Q;k++)
					 {
						temp0+=f0[i][j][z][k];

					 }
					n0[i][j][z]=temp0; //格点密度

				pressure[i][j][z]=n0[i][j][z]*R_const*T/(1.0-b*n0[i][j][z])-a*alfa_T*n0[i][j][z]*n0[i][j][z]/(1.0+2.0*b*n0[i][j][z]-b*b*n0[i][j][z]*n0[i][j][z]);  //g取值G？？？
				psi0[i][j][z]=sqrt(2.0*(pressure[i][j][z]-n0[i][j][z]/3.0)*3/G); 

				}		
 

	int id,jd,zd;
	double Fx_temp,Fy_temp,Fz_temp;

//#pragma omp parallel for private(i,j,k,z,Fx_temp,Fy_temp,Fz_temp,id,jd,zd) num_threads(2)
	for(z=1;z<LZ-1;z++)
		for(j=0;j<LY;j++)
			for(i=0;i<LX;i++)
		{
		Fx_temp=0.0;
        Fy_temp=0.0;
        Fz_temp=0.0;
			
				for(k=1;k<Q;k++)
				{
					id=i+int(e[k][0]);jd=j+int(e[k][1]);zd=z+int(e[k][2]);
					if(id>LX-1) id=0; if(id<0) id=LX-1;
					if(jd>LY-1) jd=0; if(jd<0) jd=LY-1;
					if(zd>LZ-1) zd=0; if(zd<0) zd=LZ-1;	

					  Fx_temp= Fx_temp+w[k]*e[k][0]*psi0[id][jd][zd];
                      Fy_temp= Fy_temp+w[k]*e[k][1]*psi0[id][jd][zd]; 
					  Fz_temp= Fz_temp+w[k]*e[k][2]*psi0[id][jd][zd];                     
 
			   }
			F0x[i][j][z]=-G*psi0[i][j][z]*Fx_temp;
			F0y[i][j][z]=-G*psi0[i][j][z]*Fy_temp; 
			F0z[i][j][z]=-G*psi0[i][j][z]*Fz_temp;  

		}



double mome0x,mome0y,mome0z;

#pragma omp parallel for private(i,j,k,z,mome0x,mome0y,mome0z) num_threads(2)
	for(z=0;z<LZ;z++)
		for(j=0;j<LY;j++)
			for(i=0;i<LX;i++)
		{			
				vx0[i][j][z]=vx[i][j][z]; //保存上一时刻真实速度，用于收敛判断
				vy0[i][j][z]=vy[i][j][z];
				vz0[i][j][z]=vz[i][j][z];
				mome0x=mome0y=mome0z=0.0;
				for(k=0;k<Q;k++)
				{
					mome0x+=f0[i][j][z][k]*e[k][0]; //x方向动量
					mome0y+=f0[i][j][z][k]*e[k][1]; //y方向动量
					mome0z+=f0[i][j][z][k]*e[k][2]; //z方向动量
					
				}
				mome0x=mome0x;mome0y=mome0y;mome0z=mome0z;				


				veq0x[i][j][z]=(mome0x/n0[i][j][z]); // 平衡态速度
				veq0y[i][j][z]=(mome0y/n0[i][j][z]);
				veq0z[i][j][z]=(mome0z/n0[i][j][z]);

				vx[i][j][z]=(veq0x[i][j][z]+0.5*F0x[i][j][z]/n0[i][j][z]); //真实速度
				vy[i][j][z]=(veq0y[i][j][z]+0.5*F0y[i][j][z]/n0[i][j][z]);
				vz[i][j][z]=(veq0z[i][j][z]+0.5*F0z[i][j][z]/n0[i][j][z]);

		}

			

}

//evolve
void evolve()
{
	collision();
	stream();
	para();
	
}


double Error()
{
	int i,j,z;
	double temp1,temp2,err;
	temp1=0;
	temp2=0;

//#pragma omp parallel for reduction(+:temp1,temp2)
	for(z=1;z<LZ-1;z++)
		for(i=0;i<LX;i++)
			for(j=0;j<LY;j++)
			{
				temp1+=(vx[i][j][z]-vx0[i][j][z])*(vx[i][j][z]-vx0[i][j][z])+(vy[i][j][z]-vy0[i][j][z])*(vy[i][j][z]-vy0[i][j][z])+(vz[i][j][z]-vz0[i][j][z])*(vz[i][j][z]-vz0[i][j][z]);
				temp2+=(vx[i][j][z]*vx[i][j][z]+vy[i][j][z]*vy[i][j][z]+vz[i][j][z]*vz[i][j][z]);
			}
			temp1=sqrt(temp1);
			temp2=sqrt(temp2);
			err=temp1/(temp2);
			return err;
}


void output(int m)  //输出
{
	int i,j,z; 

	ostringstream name;	
	name<<"result_"<<m<<".dat";
	ofstream out(name.str().c_str());
	out<<"Title=\"Laplace Equation\"\n"<<"VARIABLES=\"X\",\"Y\",\"Z\",\"V1\",\"V2\",\"V3\",\"Rho\",\"Pressure\"\n"<<"ZONE T=\"BOX\",I="
		<<LX<<",J="<<LY<<",K="<<LZ<<",F=POINT"<<endl;

	for(z=0;z<LZ;z++)
		for(j=0;j<LY;j++)
			for(i=0;i<LX;i++)
			{
				out<<i<<"   "<<j<<"   "<<z<<"   "<<vx[i][j][z]<<"   "<<vy[i][j][z]<<"   "<<vz[i][j][z]<<"   "<<n0[i][j][z]<<"   "<<pressure[i][j][z]<<endl;
			}

}


void output_pressure(int m)
{

	ostringstream name;
	int z;
	name<<"pressure_"<<m<<".txt";
	ofstream out(name.str().c_str());	
		for(z=0;z<LZ;z++)
		{
			out<<z<<"   "<<n0[X0][Y0][z]<<"   "<<pressure[X0][Y0][z]<<endl;
		}
		


}

//main
void main()
{
	using namespace std;
	
	e[0][0]=0.0;  e[0][1]=0.0;  e[0][2]=0.0;
	e[1][0]=1.0;  e[1][1]=0.0;  e[1][2]=0.0;
	e[2][0]=-1.0;  e[2][1]=0.0;  e[2][2]=0.0;
	e[3][0]=0.0; e[3][1]=1.0;  e[3][2]=0.0;
	e[4][0]=0.0;  e[4][1]=-1.0;  e[4][2]=0.0;

	e[5][0]=0.0;  e[5][1]=0.0;  e[5][2]=1.0;
	e[6][0]=0.0; e[6][1]=0.0;  e[6][2]=-1.0;
	e[7][0]=1.0; e[7][1]=1.0;  e[7][2]=0.0;
	e[8][0]=-1.0;  e[8][1]=1.0;  e[8][2]=0.0;
	e[9][0]=1.0;  e[9][1]=-1.0;  e[9][2]=0.0;

	e[10][0]=-1.0;  e[10][1]=-1.0;  e[10][2]=0.0;
	e[11][0]=1.0;  e[11][1]=0.0;  e[11][2]=1.0;
	e[12][0]=-1.0;  e[12][1]=0.0;  e[12][2]=1.0;
	e[13][0]=1.0;  e[13][1]=0.0;  e[13][2]=-1.0;
	e[14][0]=-1.0;  e[14][1]=0.0;  e[14][2]=-1.0;

	e[15][0]=0.0;  e[15][1]=1.0;  e[15][2]=1.0;
	e[16][0]=0.0;  e[16][1]=-1.0;  e[16][2]=1.0;
	e[17][0]=0.0;  e[17][1]=1.0;  e[17][2]=-1.0;
	e[18][0]=0.0;  e[18][1]=-1.0;  e[18][2]=-1.0;
	

	time0=clock();	
	initial();	
	printf("Start calculation, wait...\n");
	int m; //循环赋值

	for(m=0;m<=10000 ;m++)
	{
		evolve();
		time1=clock();
		if(m%5==0)
		{
			//error=Error();
			cout<<"The"<<m<<"th computation result:"<<endl<<"The densities 4,3,2,1 are:"
				<<setprecision(6)<<n0[X0][Y0][Z0]<<","<<n0[0][0][0]<<endl;
			//cout<<"The max relative error of uv is:"<<setiosflags(ios::scientific)<<error<<endl;
			printf("时间=%f秒\n",(time1-time0)/1000.0);
			
		}

		if(m%50==0)
		{
			
			output(m); //输出数据
			output_pressure(m);

		}
		
		
	}

	

    //printf("最终误差error=%e\t最终循环次数IT=%d\n",error,m);

  system("pause");

}
